Python Basics

Python is object-oriented; creating custom data objects is simple.

Variables are pointers to objects

Dynamically-typed language
	Whenever a variable is initialized, there is no need to declare a typed

Scope
	New local namespaces are created whenever a function is executed.
	Python will first look within a function to resolve a namespace; then global
	Use 'global' keyword within function to refer to a global variable
			a=20
		def my_function()
			global a
			
Data types
	Numeric
		int float complex bool
	Sequence
		str list tuple range
	Mapping
		dict
	Set
	
	Data types are objects
		greeting = 'hello world' 
			-> creating instance of string object with identity of greet and value of hello world
	
	Strings
		Immutable
		Common methods
			s.count(substring, [start, end]): number of substrings
			s.find(substring, [start, end]): return index of first substring (-1 if null)
			s.isalnum(): True if every character is alphanumeric 
			s.isalpha(): " alphabetic
			s.isdigit(): " digit
			s.join(t): join together strings
			s.lower(), s.replace(old, new [maxreplace]): replace substring (old) with new
			s.strip([characters]): remove any optional characters or whitespace
			s.split([separator], [maxsplit]): split a string separated with optional separator or whitespace and return list
			
		Strings are sequences; have support for indexing and slicing
	
	Lists are made of any data type
	
	When referencing objects, Py will create a real copy if it has no alternative
		x=1; y=2
		list1=[x,y]
		list2=list1
		list2[1]=3
		list1 #[1,3] because the y variable that list1 points to is changed.
		
		List comprehensions create a list from expressions
			l=[2,4]
			[i**3 of i in l] #[8,64]
			
			Can also build other structures
				words = 'here is a sentence'.split()
				[[word, len(word)] #[['here', 4], ['is', 2], ...]
				
			

Functions
	First class objects	
		Creation takes place at runtime
		Assigned in a data structure or as a variable
		Passed to functions as arguments
		Returned as a function result
		n.b. no hierarchy: in Py all objects first class
	Can be added to another data object
		def hi_there
			print('hi there')
		list1=[hi_there]
		list1[0] #'hi there'
	
	Higher-order function: function takes a function as argument or returns function
		Egs. map() and filter()
			lst=[1,2,3]
			list(map(lambda x: x**3, lst)) #[1,8,27]
				lambda function is anonymous function
		sort(), sorted()
			list.sort() is a method of the object list and mutates the list to sort
			sorted(list, keys) returns new sorted list
			Nice way to sort complex data structures:
				items.sort(key=lambda item: item[1])
				items #will sort items by item[1]
				
Generators
	Functions that return sequences of results reather than a single result
	Use yield statement.
	Useful to replace lists that are long and unworkable
	Improvement comes from values being generated on demand instead of saving the list in memory: elements are only returned as req
	**read more about generators**
			
OOP
	Example
		class Employee(object):
	numEmployee = 0
	def__init__(self, name, rate):
		self.owed = 0
		self.name = name
		self.rate = rate
		Employee.numEmployee += 1

	def__del__(self):
		Employee.numEmployee -= 1
		
	def hours(self, numHours):
		self.owed += numHours * self.rate
		return('%.2f hours worked' % numHours)
		
	def pay(self):
		self.owed = 0
		return('payed %s' % self.name)



	Good basis for thinking about core functionality of program
	Organization programs around data and objects and not logic and actions
		since logic and actions are embodied in objects, have a method of encapsulating the functionality so we can change objects in specific ways
	When a class is created, it is not instantiated; must assign a variable to the class.
	Functions defined in class are known as instance methods
		an instance of the class is passed as the first argument, usually 'self'
		'self' refers to the instance
	Special methods
		Start and end with two underscores
		Tend to be called by interpreter and not programmer (when you use '+' you're calling __add__()
			except __init__() #used for invoking the superclass initializer in the class definitions
		dir(object) #can be used to get the attributes list for a specified object
	Inheritance
		To modify how an existing class behaves we can use inheritance (behavior of existing method to be mod).
			inherited class is passed inside the class definition as an argument
		Refer to above:
		class specialEmployee(Employee):
	def hours(self, numHours):
	self.owed += numHours * self.rate * 2
	return('%.2f hours worked' % numHours)
	
		To define new class variable using subclass, __init__() must be defined by the subclass:
			class specialEmployee(Employee):
		def__init__(self,name,rate,bonus):
			Employee.__init__(self,name,rate) #base classes are called
			self.bonus = bonus
		def hours(self,numHours):
			self.owed += numHours * self.rate + self.bonus
			return('%.2f hours worked' %numHours)
	
	isinstance(obj1, obj2) can be used to test class membership
			
	static methods are functions that happen to be defined in a class but do not perform any operations on the instance
		defined using @staticmethod class decorator
		CANNOT access attributes of an instance
	class methods perform operations on the class
		Similar to instance method, except instead of passing the instance hiddenly as a first parameter, passing class itself as first parameter
		Since we're passing class to the moethod, no instance is involved.
		use @classmethod to defined them
		class gets passed as initial argument (by convention, cls)
				class Aexp(object):
			base = 2
			@classmethod
			def exp(cls,x):
				return(cls.base**x)
			
			class Bexp(Aexp):
				base=3
			#Bexp will inherit from the class Aexp and the base class variable is changed to 3
		More info on class methods: https://stackoverflow.com/questions/17134653/difference-between-class-and-instance-methods
		
	Encapsulation
		When you want "private" attributes in a method, add underscores: __privateMethod()
			this doesn't actually hide the attributes, just prevents name conflicts; instance of class def by user that defines
				a _bool_() or _len_() method that returns False or zero.
		
			
Structures and data types
	Falsy values: 'None'; False; float, integer, complex 0; empty sequences or mapping; 
	'and', 'or' operators are short-circuited
		Operators: // is integer quotient
		Membership operators: 'in', 'not in' test for variables in given sequences 
			e.g. x in y # will return True should the variable x be in y
			'is' compares the identity of objects
				x=[1,2]; y=[1,2] x == y # True; x is y # False; x = y #assignment, now x is y True
		Data types fit into 3 categories: Numeric, Sequence, Mapping (also 'None', representative of Null)
			Every single Py value has a data type
			Category     Name     Desc.
			None		None		Null Obj
			Numeric		int			Integer
						float		Floating point number
						complex		Complex Number
						bool		Boolean
			Sequences	str			Char string
						list		lists arb objects
						tuple		groups arbitrary
			Objects		range		creates ranges of integers
			Mapping		dict		dictionary containing key-value pairs
						set			mutable collection of unordered, unique items
						frozenset	immutable set
			
			Sequences
				For every immutable type, an operation will return a value; it will not change the value
			Tuple
				Immutable sequence that contains arbitrary objects, indexed by ints greater than zero.
				Hashable: can sort lists of tuples, can be used as dictionary keys
				Syntax: sequence of values, separated by comma
					tpl = ('a', 'b', 'c') # trailing comma must be used with one element t=('a',) # else interpreted as str
				Create with built-in tuple() function
				Can assign multiple variables at once
					l = ('one', 'two')
					x, y = l # x and y are assigned respectively to 'one', 'two'
						swap: x, y = y, x
			Dictionary
				arbitrary collection of objects that are indexed by immutable objects (strings/numbers)
					i.e. dictionary itself is mutable, its index keys must be immutable
				e.g.
					d = {'one':1, 'two':2, 'three':3} # dict created
					d['four'] = 4 # key/value item added
					d.update({'five':5, 'six':6}) # multiple items added
				when 'in' operator used, a hashing algorithm is used so lookups are O(1)
				Items are not ordered in dictionaries (they are with strings and lists)
				Sort: sorted(list(d) # sorts keys
				Can be used well for text-analysis (e.g. occurrences of each word in a text)
			Set
				Mutable, unordered collection containing unique, mutable items
				Often used for mathematical operations like union, intersection, complement, difference
				NO slicing/indexing operation; valuees don't have keys like dicts do
				a=set() # create empty set; curlies creates dict
				Members can be of different types, but must be immutable (no lists/dicts, cannot be member of another set)
					Hashable types have hash value that remains same; immutable types are of a hashable type
				Frozensets are immutable and thus hashable
			Modules for algorithms and data structures
				Collections (e.g. 'from collections import deque')
					Deque: double-ended queue
						similar to lists with support for appends that are thread-safe (synchronous operations safe) and memory-efficient
						Mutable
						Can be assigned by index but cannot be sliced
						Advantage over list: much faster to insert an item at the start
						e.g. append(), appendleft(), extend(), extendleft(), pop(), popleft(), rotate()
						Can slice to return list dlist(itertools.isslice(dq, 2, 6))
						maxlen() is good for deques used as circular buffers
					ChainMap
						Used to link several dictionaries or mappings to in effect make them same object
						Mappings for CM object are stored in lists and use maps[i] attribute to access them, retrieving the ith dict
							Dicts in CM are ordered
						CM > dict: can hang on to values set previously using cm.new_child().
					Counter
						Subclass of dict where each of the keys in the dict is a hashable object; val associated with key is int count
						A counter will return a zero count for a missing item, dict will raise error
					Ordered Dictionary
						Remember the order of insertion, when iterated over, values returned in order they were inserted (normal dict has arb order)
					Default Dict
						Nice for creating dicts
					Named Tuple
						Can give tuples name (useful if managing many tuples)
							space = namedtuple('space', 'x y z')
					Arrays
						Like lists but contents must be of a single type
						
						
						